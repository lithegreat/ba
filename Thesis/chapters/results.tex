\section{Evaluation}

\subsection{Setup}

In this evaluation, the custom operations from OpenASIP were translated into CoreDSL syntax and then transformed into LLVM using the Seal5 framework. This LLVM representation allowed for seamless integration into the benchmarking tool MLonMCU, which was used to test the performance of the custom instruction set on various machine learning models. The primary benchmark model evaluated was \texttt{coremark}, a standard benchmark for assessing the performance of embedded systems.

In addition to \texttt{coremark}, more benchmark models are scheduled for testing and will be added in future versions of this paper. Each benchmark provides insights into the performance improvements offered by the custom operations in different workloads and applications.

\subsection{Performance}

The performance evaluation consists of several metrics, including the total number of instructions executed, ROM and RAM usage, and the number of clock cycles relative to the baseline configuration. The results from the initial benchmark runs are summarized in the table below:

\begin{table}[h!]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        \textbf{Session} & \textbf{Run} & \textbf{Total Instructions} & \textbf{Total ROM} & \textbf{Total RAM} & \textbf{Total Cycles (rel.)} \\
        \hline
        50  & 0 & 3,877,474 & 50,136 & 4,796 & 1.000 \\
        50  & 1 & 3,805,746 & 50,120 & 4,796 & 0.982 \\
        \hline
    \end{tabular}
    \caption{Summary of Performance Metrics for Coremark on ETISS using MLonMCU}
\end{table}

Additionally, the custom OpenASIP operations executed during the benchmark include \texttt{openasip\_base\_shl1add}, \texttt{openasip\_base\_mac}, \texttt{openasip\_base\_shl2add}, \texttt{openasip\_base\_lt}, and \texttt{openasip\_base\_maxu}. The execution count and relative usage of these operations are shown below:

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Operation} & \textbf{Executions} & \textbf{Relative Usage (\%)} \\
        \hline
        openasip\_base\_shl1add & 60,503 & 1.6\% \\
        openasip\_base\_mac     & 58,347 & 1.5\% \\
        openasip\_base\_shl2add & 19,876 & 0.5\% \\
        openasip\_base\_lt      & 12,960 & 0.3\% \\
        openasip\_base\_maxu    & 41     & 0.0\% \\
        \hline
    \end{tabular}
    \caption{Execution Count of Custom OpenASIP Operations}
\end{table}

The results indicate that the custom operations, such as \texttt{openasip\_base\_shl1add} and \texttt{openasip\_base\_mac}, were frequently executed, contributing to key operations involving shifts and multiplications in the benchmark. The integration of the custom instruction set into LLVM via Seal5 and its subsequent benchmarking using MLonMCU demonstrates the effectiveness of this workflow in evaluating instruction set performance.

\subsection{Discussion}

The performance results indicate that the custom instructions provided modest improvements in reducing the number of executed instructions and clock cycles. Using MLonMCU, we were able to evaluate these custom instructions in the context of a real-world machine learning benchmark, confirming the feasibility of integrating custom ISA extensions through the LLVM backend generated by Seal5.

Although the performance gains observed were moderate, this evaluation demonstrates the potential for custom operations to optimize specific computational workloads. Further tests will be conducted using additional machine learning models, which are expected to highlight more substantial improvements in performance across a broader range of applications.

Future work will continue to refine the instruction set, expanding the pool of custom operations, and testing more diverse workloads to better understand the full impact of custom instruction sets on performance in embedded systems.
