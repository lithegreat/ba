InstructionSet OpenASIP_base extends RV32I {
    instructions {
        // Array indexing for 16-bit data types
        SHL1ADD {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHL1ADD", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Array indexing for 32-bit data types
        SHL2ADD {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHL2ADD", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Integer addition. Output 3 is sum of inputs 1 and 2.
        ADD {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.ADD", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Integer subtraction. Input 1 is minuend,  input 2 is subtrahend and output 3 is difference.
        SUB {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SUB", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Equality comparison. Output 3 returns '1' if inputs 1 and 2 are equal and otherwise returns '0'.
        EQ {
            operands: {
                unsigned<5> rd [[reg_type=u1]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.EQ", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Greater-than signed integer comparison. 
        // Output returns '1' if input 1 is greater than input 2 and otherwise returns '0'.
        GT {
            operands: {
                unsigned<5> rd [[reg_type=s1]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.GT", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Greater-than unsigned integer comparison. Output returns '1' if input 1 is greater than input 2 and otherwise returns '0'.
        GTU {
            operands: {
                unsigned<5> rd [[reg_type=u1]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.GTU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Less-than signed integer comparison.
        LT {
            operands: {
                unsigned<5> rd [[reg_type=u1]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.LT", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Less-than unsigned integer comparison.
        LTU {
            operands: {
                unsigned<5> rd [[reg_type=u1]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.LTU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Not equal signed integer comparison.
        NE {
            operands: {
                unsigned<5> rd [[reg_type=s1]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.NE", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Greater or equal signed integer comparison.
        GE {
            operands: {
                unsigned<5> rd [[reg_type=s1]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.GE", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Greater or equal unsigned integer comparison.
        GEU {
            operands: {
                unsigned<5> rd [[reg_type=u1]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.GEU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Less or equal signed integer comparison.
        LE {
            operands: {
                unsigned<5> rd [[reg_type=s1]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.LE", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Less or equal unsigned integer comparison.
        LEU {
            operands: {
                unsigned<5> rd [[reg_type=u1]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.LEU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Left logical shift. Input 1 is value to be shifted and input 2 is shift amount. Output 3 is result from operation.
        SHL {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=u5]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHL", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Arithmetic shift right (sign bit duplicated). Input 1 is value to be shifted and input 2 is shift amount. Output 3 is result from operation.
        SHR {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=u5]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHR", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Logical shift right (most siginificant bits zeroed). Input 1 is value to be shifted and input 2 is shift amount. Output 3 is result from operation.
        SHRU {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u5]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHRU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Bitwise AND. Operands 1 and 2 are inputs and 3 is output result.
        AND {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.AND", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Inclusive OR. Operands 1 and 2 are inputs and 3 is output result.
        IOR {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.IOR", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Exclusive OR. Operands 1 and 2 are inputs and 3 is output result.
        XOR {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.XOR", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Returns the smaller of the two signed integer values. Operands 1 and 2 are inputs and 3 is output result.
        MIN {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MIN", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Returns the larger of the two signed input values. Operands 1 and 2 are inputs and 3 is output result.
        MAX {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MAX", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Returns the smaller of the two unsigned input values.
        MINU {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MINU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Returns the larger of the two unsigned input values.
        MAXU {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MAXU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // 32-bit integer multiplication of the inputs 1 and 2 with lower result bits in the output 3.
        MUL {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MUL", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // 32-bit integer multiplication of the signed inputs 1 and 2 with higher result bits in the output 3.
        MULHI {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MULHI", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // 32-bit integer multiplication of the unsigned inputs 1 and 2 with higher result bits in the output 3.
        MULHIU {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MULHIU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // 32-bit integer multiplication of the signed input 1 and unsigned input 2 with higher result bits in the output 3.
        MULHISU {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MULHISU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Integer division.
        DIV {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.DIV", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Unsigned integer division.
        DIVU {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.DIVU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Multiply and accumulate (signed integer).
        MAC {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
                unsigned<5> rs3 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MAC", "{name(rd)}, {name(rs1)}, {name(rs2)}, {name(rs3)}"};
            behavior: {};
        }
        // Rotate left.
        ROTL {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.ROTL", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Rotate right.
        ROTR {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.ROTR", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Integer modulo.
        MOD {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MOD", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Integer remainder.
        REM {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.REM", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Integer modulo (unsigned)
        MODU {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MODU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Integer remainder (unsigned)
        REMU {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.REMU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Does a bitwise negation (NOT) on the 2nd input followed by AND of the 1st input and the negated 2nd output. Special instruction in TI C64X.
        ANDN {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.ANDN", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Leftmost Bit Detection (from TI C64X). Counts the number of 0's or 1's in the bit representation of operand 1 before the first 1 or 0. 2nd operand is used to tell whether to search for a 0 or 1.
        LMBD {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.LMBD", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Select one of two values
        SELECT {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
                unsigned<5> rs3 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SELECT", "{name(rd)}, {name(rs1)}, {name(rs2)}, {name(rs3)}"};
            behavior: {};
        }
    }
}
