InstructionSet OpenASIP_base extends RV32I {
    instructions {
        // Integer addition. Output 3 is sum of inputs 1 and 2.
        OpenASIP_base_ADD {
            encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                X[rd % RFS] = X[rs1 % RFS] + X[rs2 % RFS];
            }
        }
        // Integer subtraction. Input 1 is minuend,  input 2 is subtrahend and output 3 is difference.
        OpenASIP_base_SUB {
            encoding: 7'b0000001 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                X[rd % RFS] = X[rs1 % RFS] - X[rs2 % RFS];
            }
        }
        // Equality comparison. Output 3 returns '1' if inputs 1 and 2 are equal and otherwise returns '0'.
        OpenASIP_base_EQ {
            encoding: 7'b0000010 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                if (X[rs1 % RFS] == X[rs2 % RFS]) {
                    X[rd % RFS] = 1;
                } else {
                    X[rd % RFS] = 0;
                }
            }
        }
        // Greater-than signed integer comparison. 
        // Output returns '1' if input 1 is greater than input 2 and otherwise returns '0'.
        OpenASIP_base_GT {
            encoding: 7'b0000011 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                signed<32> in1 = static_cast<signed<32>>(X[rs1 % RFS]);
                signed<32> in2 = static_cast<signed<32>>(X[rs2 % RFS]);
                X[rd % RFS] = (in1 > in2) ? 1 : 0;
            }
        }
        // Greater-than unsigned integer comparison. Output returns '1' if input 1 is greater than input 2 and otherwise returns '0'.
        OpenASIP_base_GTU {
            encoding: 7'b0000100 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                X[rd % RFS] = (X[rs1 % RFS] > X[rs2 % RFS]) ? 1 : 0;
            }
        }
        // Less-than signed integer comparison.
        OpenASIP_base_LT {
            encoding: 7'b0000101 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                }
        }
        // Less-than unsigned integer comparison.
        OpenASIP_base_LTU {
            encoding: 7'b0000110 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                }
        }
        // Left logical shift. Input 1 is value to be shifted and input 2 is shift amount. Output 3 is result from operation.
        OpenASIP_base_SHL {
            encoding: 7'b0000111 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                X[rd % RFS] = X[rs1 % RFS] << X[rs2 % RFS];
            }
        }
        // Arithmetic shift right (sign bit duplicated). Input 1 is value to be shifted and input 2 is shift amount. Output 3 is result from operation.
        OpenASIP_base_SHR {
            encoding: 7'b0001000 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                signed<32> int1 = static_cast<signed<32>>(X[rs1 % RFS]);
                signed<32> int2 = static_cast<signed<32>>(X[rs2 % RFS]);
            
                if (int2 > min(
                        static_cast<signed<32>>(BWIDTH(rd % RFS)), 
                        static_cast<signed<32>>(32))) {
                    X[rd % RFS] = 0;
                    return true;
                }
                
                signed<32> int3 = int1 >> int2;
                X[rd % RFS] = static_cast<signed<32>>(int3);
            }
        }
        // Bitwise AND. Operands 1 and 2 are inputs and 3 is output result.
        OpenASIP_base_AND {
            encoding: 7'b0001001 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                X[rd % RFS] = X[rs1 % RFS] & X[rs2 % RFS];
            }
        }
        // Inclusive OR. Operands 1 and 2 are inputs and 3 is output result.
        OpenASIP_base_IOR {
            encoding: 7'b0001010 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                X[rd % RFS] = X[rs1 % RFS] | X[rs2 % RFS];
            }
        }
        // Exclusive OR. Operands 1 and 2 are inputs and 3 is output result.
        OpenASIP_base_XOR {
            encoding: 7'b0001011 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                X[rd % RFS] = X[rs1 % RFS] ^ X[rs2 % RFS];
            }
        }
        // Returns the smaller of the two signed integer values. Operands 1 and 2 are inputs and 3 is output result.
        OpenASIP_base_MIN {
            encoding: 7'b0001100 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                signed<32> in1 = static_cast<signed<32>>(INT(rd % RFS));
                signed<32> in2 = static_cast<signed<32>>(INT(X[rs1 % RFS] == X[rs2 % RFS]));
                signed<32> in3 = (in1 < in2) ? in1 : in2;
                X[rd % RFS] = static_cast<signed<32>>(in3);
            }
        }
        // Returns the larger of the two signed input values. Operands 1 and 2 are inputs and 3 is output result.
        OpenASIP_base_MAX {
            encoding: 7'b0001101 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                signed<32> in1 = static_cast<signed<32>>(INT(rd % RFS));
                signed<32> in2 = static_cast<signed<32>>(INT(X[rs1 % RFS] == X[rs2 % RFS]));
                signed<32> in3 = (in1 > in2) ? in1 : in2;
                X[rd % RFS] = static_cast<signed<32>>(in3);
            }
        }
        // Returns the smaller of the two unsigned input values.
        OpenASIP_base_MINU {
            encoding: 7'b0001110 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                unsigned<32> in1 = X[rs1 % RFS];
                unsigned<32> in2 = X[rs2 % RFS];
            
                if (in1 < in2) {
                    X[rd % RFS] = in1;
                } else {
                    X[rd % RFS] = in2;
                }
            }
        }
        // Returns the larger of the two unsigned input values.
        OpenASIP_base_MAXU {
            encoding: 7'b0001111 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                unsigned<32> in1 = X[rs1 % RFS];
                unsigned<32> in2 = X[rs2 % RFS];
            
                if (in1 > in2) {
                    X[rd % RFS] = in1;
                } else {
                    X[rd % RFS] = in2;
                }
            }
        }
        // 32-bit integer multiplication of the inputs 1 and 2 with lower result bits in the output 3.
        OpenASIP_base_MUL {
            encoding: 7'b0010000 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                X[rd % RFS] = X[rs1 % RFS]*X[rs2 % RFS];
            }
        }
        // Integer division.
        OpenASIP_base_DIV {
            encoding: 7'b0010001 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                if (X[rs2 % RFS] != 0)
                
                    X[rd % RFS] = static_cast<signed<32>>(
                	(static_cast<signed<32>>(X[rs1 % RFS]) / static_cast<signed<32>>(X[rs2 % RFS])));
            }
        }
        // Unsigned integer division.
        OpenASIP_base_DIVU {
            encoding: 7'b0010010 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                if (X[rs2 % RFS] != 0)
                
                    X[rd % RFS] = X[rs1 % RFS] / X[rs2 % RFS];
            }
        }
        // Rotate right.
        OpenASIP_base_ROTR {
            encoding: 7'b0010011 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                unsigned<32> in1 = X[1 % RFS];
                unsigned<32> in2 = X[2 % RFS];
                in2 = in2 % 32;
                X[rd % RFS] = (in1 >> in2) | (in1 << (32 - in2));
            }
        }
        // Integer modulo.
        OpenASIP_base_MOD {
            encoding: 7'b0010100 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                if (X[rs2 % RFS] != 0)
                            
                    signed<32> in1 = static_cast<signed<32>>(X[rs1 % RFS]);
                    signed<32> in2 = static_cast<signed<32>>(X[rs2 % RFS]);
                    signed<32> out1 = in1 % in2;
                    X[rd % RFS] = static_cast<signed<32>>(out1);
            }
        }
        // Integer remainder.
        OpenASIP_base_REM {
            encoding: 7'b0010101 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                if (X[rs2 % RFS] != 0)
                            
                    signed<32> in1 = static_cast<signed<32>>(X[rs1 % RFS]);
                    signed<32> in2 = static_cast<signed<32>>(X[rs2 % RFS]);
                    signed<32> out1 = remainder(in1,in2);
                    X[rd % RFS] = static_cast<signed<32>>(out1);
            }
        }
        // Integer modulo (unsigned)
        OpenASIP_base_MODU {
            encoding: 7'b0010110 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                if (X[rs2 % RFS] != 0)    
                
                    unsigned<32> tempIn1 = X[rs1 % RFS];
                    unsigned<32> tempIn2 = X[rs2 % RFS];
                    unsigned int in1 = unsigned int(tempIn1);
                    unsigned int in2 = unsigned int(tempIn2);
                
                    unsigned int out1 = in1 % in2;
                
                    X[rd % RFS] = static_cast<unsigned<32>>(out1);
            }
        }
        // Integer remainder (unsigned)
        OpenASIP_base_REMU {
            encoding: 7'b0010111 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly: "{name(rd1)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                if (X[rs2 % RFS] != 0)    
                
                    unsigned<32> tempIn1 = X[rs1 % RFS];
                    unsigned<32> tempIn2 = X[rs2 % RFS];
                    unsigned int in1 = unsigned int(tempIn1);
                    unsigned int in2 = unsigned int(tempIn2);
                
                    unsigned int out1 = remainder(in1, in2);
                
                    X[rd % RFS] = static_cast<unsigned<32>>(out1);
            }
        }
    }
}
