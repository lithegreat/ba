InstructionSet OpenASIP_base extends RV32I {
    instructions {
        // Array indexing for 16-bit data types
        SHL1ADD {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHL1ADD", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Array indexing for 32-bit data types
        SHL2ADD {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHL2ADD", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Integer addition. Output 3 is sum of inputs 1 and 2.
        ADD {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.ADD", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Integer subtraction. Input 1 is minuend,  input 2 is subtrahend and output 3 is difference.
        SUB {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SUB", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Equality comparison. Output 3 returns '1' if inputs 1 and 2 are equal and otherwise returns '0'.
        EQ {
            operands: {
                unsigned<5> rd [[reg_type=u1]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.EQ", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Greater-than signed integer comparison. 
        // Output returns '1' if input 1 is greater than input 2 and otherwise returns '0'.
        GT {
            operands: {
                unsigned<5> rd [[reg_type=s1]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.GT", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Greater-than unsigned integer comparison. Output returns '1' if input 1 is greater than input 2 and otherwise returns '0'.
        GTU {
            operands: {
                unsigned<5> rd [[reg_type=u1]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.GTU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Less-than signed integer comparison.
        LT {
            operands: {
                unsigned<5> rd [[reg_type=u1]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.LT", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Less-than unsigned integer comparison.
        LTU {
            operands: {
                unsigned<5> rd [[reg_type=u1]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.LTU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Not equal signed integer comparison.
        NE {
            operands: {
                unsigned<5> rd [[reg_type=s1]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.NE", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Greater or equal signed integer comparison.
        GE {
            operands: {
                unsigned<5> rd [[reg_type=s1]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.GE", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Greater or equal unsigned integer comparison.
        GEU {
            operands: {
                unsigned<5> rd [[reg_type=u1]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.GEU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Less or equal signed integer comparison.
        LE {
            operands: {
                unsigned<5> rd [[reg_type=s1]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.LE", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Less or equal unsigned integer comparison.
        LEU {
            operands: {
                unsigned<5> rd [[reg_type=u1]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.LEU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Left logical shift. Input 1 is value to be shifted and input 2 is shift amount. Output 3 is result from operation.
        SHL {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=u5]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHL", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Left logical shift by 1. Input 1 is value to be shifted and Output 2 is result from operation.
        SHL1_32 {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHL1_32", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Left logical shift by 2. Input 1 is value to be shifted and Output 2 is result from operation.
        SHL2_32 {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHL2_32", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Left logical shift by 4. Input 1 is value to be shifted and Output 2 is result from operation.
        SHL4_32 {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHL4_32", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Left logical shift by 8. Input 1 is value to be shifted and Output 2 is result from operation.
        SHL8_32 {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHL8_32", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Left logical shift by 16. Input 1 is value to be shifted and Output 2 is result from operation.
        SHL16_32 {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHL16_32", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Arithmetic shift right (sign bit duplicated). Input 1 is value to be shifted and input 2 is shift amount. Output 3 is result from operation.
        SHR {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=u5]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHR", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Arithmetic shift right by one bit.
        SHR1_32 {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHR1_32", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Arithmetic shift right by two bits.
        SHR2_32 {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHR2_32", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Arithmetic shift right by four bits
        SHR4_32 {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHR4_32", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Arithmetic shift right by eight bits.
        SHR8_32 {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHR8_32", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Arithmetic shift right by 16 bits.
        SHR16_32 {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHR16_32", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Logical shift right (most siginificant bits zeroed). Input 1 is value to be shifted and input 2 is shift amount. Output 3 is result from operation.
        SHRU {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u5]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHRU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Logical shift right by one bit.
        SHRU1_32 {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHRU1_32", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Logical shift right by two bits
        SHRU2_32 {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHRU2_32", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Logical shift right by four bits
        SHRU4_32 {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHRU4_32", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Logical shift right by eight bits
        SHRU8_32 {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHRU8_32", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Logical shift right by 16 bits
        SHRU16_32 {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SHRU16_32", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Bitwise AND. Operands 1 and 2 are inputs and 3 is output result.
        AND {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.AND", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Inclusive OR. Operands 1 and 2 are inputs and 3 is output result.
        IOR {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.IOR", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Exclusive OR. Operands 1 and 2 are inputs and 3 is output result.
        XOR {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.XOR", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Returns the smaller of the two signed integer values. Operands 1 and 2 are inputs and 3 is output result.
        MIN {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MIN", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Returns the larger of the two signed input values. Operands 1 and 2 are inputs and 3 is output result.
        MAX {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MAX", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Returns the smaller of the two unsigned input values.
        MINU {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MINU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Returns the larger of the two unsigned input values.
        MAXU {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MAXU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // sign extend from 1 bit to 32 bits
        SXBW {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s1]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SXBW", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Sign extend from 8 bits of the input 1 to 32 bits into output 2.
        SXQW {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s8]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SXQW", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Sign extend from 16 bits of of the input 1 to 32 bits into output 2.
        SXHW {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s16]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SXHW", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // truncate 32 bit int to 16 bit int
        TRUNCWH {
            operands: {
                unsigned<5> rd [[reg_type=s16]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.TRUNCWH", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Arithmetic negation, signed integer.
        NEG {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.NEG", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // 32-bit integer multiplication of the inputs 1 and 2 with lower result bits in the output 3.
        MUL {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MUL", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // 32-bit integer multiplication of the signed inputs 1 and 2 with higher result bits in the output 3.
        MULHI {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MULHI", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // 32-bit integer multiplication of the unsigned inputs 1 and 2 with higher result bits in the output 3.
        MULHIU {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MULHIU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // 32-bit integer multiplication of the signed input 1 and unsigned input 2 with higher result bits in the output 3.
        MULHISU {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MULHISU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Integer division.
        DIV {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.DIV", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Unsigned integer division.
        DIVU {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.DIVU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Multiply and accumulate (signed integer).
        MAC {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
                unsigned<5> rs3 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MAC", "{name(rd)}, {name(rs1)}, {name(rs2)}, {name(rs3)}"};
            behavior: {};
        }
        // Rotate left.
        ROTL {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.ROTL", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Rotate right.
        ROTR {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.ROTR", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Absolute value.
        ABS {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.ABS", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Integer modulo.
        MOD {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MOD", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Integer remainder.
        REM {
            operands: {
                unsigned<5> rd [[reg_type=s32]] [[out]];
                unsigned<5> rs1 [[reg_type=s32]] [[in]];
                unsigned<5> rs2 [[reg_type=s32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.REM", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Integer modulo (unsigned)
        MODU {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.MODU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Integer remainder (unsigned)
        REMU {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.REMU", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Bitwise negation.
        NOT {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.NOT", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Does a bitwise negation (NOT) on the 2nd input followed by AND of the 1st input and the negated 2nd output. Special instruction in TI C64X.
        ANDN {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.ANDN", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // Leftmost Bit Detection (from TI C64X). Counts the number of 0's or 1's in the bit representation of operand 1 before the first 1 or 0. 2nd operand is used to tell whether to search for a 0 or 1.
        LMBD {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.LMBD", "{name(rd)}, {name(rs1)}, {name(rs2)}"};
            behavior: {};
        }
        // The "default streaming" operation for querying input buffer status.
        // 
        // Trigger with 0.
        // 
        // Return an integer with the following meanings:
        // 
        // 0 = buffer empty
        // 1 = not empty nor full (implies a buffer size > 1 sample and that there is at least one sample in the buffer)
        // 2 = buffer full
        // 
        // This operation allows handling stream buffer underflow without a global lock, thus allows doing something useful (run another thread, for example) while the buffer is empty.
        STREAM_IN_STATUS {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.STREAM_IN_STATUS", "{name(rd)}, {name(rs1)}"};
            behavior: {};
        }
        // Control leds by writing a bit pattern. Bit 1 switches a led on and 0 switches off.
        LEDS {
            operands: {
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.LEDS", "{name(rs1)}"};
            behavior: {};
        }
        // Select one of two values
        SELECT {
            operands: {
                unsigned<5> rd [[reg_type=u32]] [[out]];
                unsigned<5> rs1 [[reg_type=u32]] [[in]];
                unsigned<5> rs2 [[reg_type=u32]] [[in]];
                unsigned<5> rs3 [[reg_type=u32]] [[in]];
            }
            encoding: auto;
            assembly: {"OpenASIP_base.SELECT", "{name(rd)}, {name(rs1)}, {name(rs2)}, {name(rs3)}"};
            behavior: {};
        }
    }
}
